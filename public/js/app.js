// Backend URL configuration
const BACKEND_URL = window.APP_CONFIG?.BACKEND_URL || "http://localhost:3000";

// Tracker: dialect ‚Üí Set of flagged IDs
const flagged = {};

// Load dialects from backend
async function loadDialects(showLoading = false) {
  try {
    const dialectSelect = document.getElementById('dialect');
    const currentValue = dialectSelect.value; // Remember current selection
    const wasDisabled = dialectSelect.disabled;
    
    if (showLoading) {
      dialectSelect.innerHTML = '<option value=""> Loading dialects...</option>';
      dialectSelect.disabled = true;
    }
    
    const response = await fetch(`${BACKEND_URL}/api/dialects`);
    if (!response.ok) throw new Error('Failed to fetch dialects');
    
    const data = await response.json();
    if (!data.success) throw new Error(data.message || 'Failed to load dialects');
    
    // Clear and rebuild options
    dialectSelect.innerHTML = '';
    
    // Add default option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = '-- ‡¶â‡¶™‡¶≠‡¶æ‡¶∑‡¶æ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® --';
    dialectSelect.appendChild(defaultOption);
    
    // Group dialects by label (division/region)
    const groupedDialects = data.dialects.reduce((groups, dialect) => {
      const label = dialect.label || 'other';
      if (!groups[label]) {
        groups[label] = [];
      }
      groups[label].push(dialect);
      return groups;
    }, {});
    
    // Sort groups: divisions first, then regions
    const groupOrder = ['devision', 'region'];
    const sortedGroups = groupOrder.filter(group => groupedDialects[group]);
    
    // Add grouped dialects to dropdown
    sortedGroups.forEach(groupLabel => {
      const dialects = groupedDialects[groupLabel];
      
      // Create optgroup
      const optgroup = document.createElement('optgroup');
      const groupTitle = groupLabel === 'devision' ? '‡¶¨‡¶ø‡¶≠‡¶æ‡¶ó‡¶∏‡¶Æ‡ßÇ‡¶π' : '‡¶Ö‡¶û‡ßç‡¶ö‡¶≤‡¶∏‡¶Æ‡ßÇ‡¶π';
      optgroup.label = groupTitle;
      
      // Add dialects to optgroup
      dialects.forEach(dialect => {
        const option = document.createElement('option');
        option.value = dialect.code;
        option.textContent = `${dialect.name} (${dialect.recorded}/${dialect.total} - ${dialect.percentage}%)`;
        
        // Restore previous selection if it exists
        if (dialect.code === currentValue) {
          option.selected = true;
        }
        
        optgroup.appendChild(option);
      });
      
      dialectSelect.appendChild(optgroup);
    });
    
    console.log(`Loaded ${data.dialects.length} dialects from database${showLoading ? ' (refreshed)' : ''}`);
    
  } catch (error) {
    console.error('Error loading dialects:', error);
    const dialectSelect = document.getElementById('dialect');
    dialectSelect.innerHTML = '<option value=""> Error loading dialects</option>';
  } finally {
    // Re-enable dropdown only if it was disabled by this function
    const dialectSelect = document.getElementById('dialect');
    if (showLoading || dialectSelect.disabled) {
      dialectSelect.disabled = false;
    }
  }
}

// UI elements
const sentenceEl = document.getElementById("currentSentence");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const statusEl = document.getElementById("status");
const dialectSel = document.getElementById("dialect");
const floating = document.getElementById("recordingBox");
const previewSection = document.getElementById("previewSection");
const audioPreview = document.getElementById("audioPreview");
const submitBtn = document.getElementById("submitBtn");
const retryBtn = document.getElementById("retryBtn");

// Recording state
let mediaRecorder, audioChunks = [];
let currentIndex = 0;
let currentSentence = null;
let currentDialect = "";
let recordedBlob = null;

// Initialize the app
async function initApp() {
  await loadDialects();
  
  // Add manual refresh button functionality
  const dialectSelect = document.getElementById('dialect');
  const refreshButton = document.getElementById('refreshDialects');
  
  // Track if we're already refreshing to avoid multiple simultaneous calls
  let isRefreshing = false;
  
  // Manual refresh button
  refreshButton.addEventListener('click', async () => {
    if (!isRefreshing) {
      isRefreshing = true;
      refreshButton.disabled = true;
      refreshButton.textContent = '‚è≥';
      
      await loadDialects(true);
      
      refreshButton.disabled = false;
      refreshButton.textContent = 'üîÑ';
      isRefreshing = false;
    }
  });
}

// Load dialects when page loads
document.addEventListener('DOMContentLoaded', initApp);

// Fetch next index from backend
async function getNextIndex(dialect) {
  const url = `${BACKEND_URL}/api/next-index?dialect=${encodeURIComponent(dialect)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("next-index failed");
  const data = await res.json();
  return data.next_index ?? 0;
}

// Fetch next sentence from backend
async function getNextSentence(dialect) {
  const url = `${BACKEND_URL}/api/next-sentence?dialect=${encodeURIComponent(dialect)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("next-sentence failed");
  const data = await res.json();
  return data;
}

// Get selected gender
function getSelectedGender() {
  const genderRadios = document.querySelectorAll('input[name="gender"]');
  for (const radio of genderRadios) {
    if (radio.checked) {
      return radio.value;
    }
  }
  return null;
}

// Validate inputs before recording
function validateInputs() {
  const selectedGender = getSelectedGender();
  const selectedDialect = dialectSel.value;
  
  if (!selectedGender) {
    alert("‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶≤‡¶ø‡¶ô‡ßç‡¶ó ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®");
    return false;
  }
  
  if (!selectedDialect) {
    alert("‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶™‡¶≠‡¶æ‡¶∑‡¶æ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®");
    return false;
  }
  
  return true;
}

// Reset UI to initial state
function resetUI() {
  previewSection.classList.add("hidden");
  sentenceEl.textContent = "‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶ï‡ßç‡¶Ø ‡¶Ü‡¶∏‡¶¨‡ßá‡•§";
  statusEl.textContent = "‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø '‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶∂‡ßÅ‡¶∞‡ßÅ' ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®";
  startBtn.disabled = false;
  stopBtn.disabled = true;
  recordedBlob = null;
}

startBtn.onclick = async () => {
  if (!validateInputs()) return;
  
  currentDialect = dialectSel.value;

  try { 
    currentIndex = await getNextIndex(currentDialect);
    
    // Get next sentence from backend
    const sentenceData = await getNextSentence(currentDialect);
    
    if (!sentenceData.success || !sentenceData.sentence) {
      alert(sentenceData.message || "‡¶è‡¶á ‡¶â‡¶™‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶¨ ‡¶¨‡¶æ‡¶ï‡ßç‡¶Ø ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§");
      return;
    }
    
    currentSentence = sentenceData.sentence;
    sentenceEl.textContent = currentSentence.text;
    
    // Show progress
    if (sentenceData.progress) {
      console.log(`Progress: ${sentenceData.progress.recorded}/${sentenceData.progress.total} (${sentenceData.progress.percentage}%)`);
    }
  }
  catch (e) { console.error(e); alert("‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ"); return; }

  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const mime = MediaRecorder.isTypeSupported("audio/webm;codecs=opus") ? "audio/webm;codecs=opus" :
               (MediaRecorder.isTypeSupported("audio/webm") ? "audio/webm" : "");
  mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);

  audioChunks = [];
  mediaRecorder.ondataavailable = e => { if (e.data.size) audioChunks.push(e.data); };

  mediaRecorder.onstop = async () => {
    // Create blob for preview
    recordedBlob = new Blob(audioChunks, { type: mime || "application/octet-stream" });
    
    // Create URL for audio preview
    const audioURL = URL.createObjectURL(recordedBlob);
    audioPreview.src = audioURL;
    
    // Show preview section
    previewSection.classList.remove("hidden");
    
    // Update status
    statusEl.textContent = "‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶°‡¶ø‡¶Ç ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®! ‡¶™‡ßç‡¶∞‡¶ø‡¶≠‡¶ø‡¶â ‡¶∂‡ßÅ‡¶®‡ßÅ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ú‡¶Æ‡¶æ ‡¶¶‡¶ø‡¶® ‡¶¨‡¶æ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®‡•§";
    
    // Hide floating recording box
    floating.classList.add("hidden");
    
    // Enable start button for retry
    startBtn.disabled = false;
    stopBtn.disabled = true;
    
    // Stop all media tracks
    stream.getTracks().forEach(track => track.stop());
  };

  mediaRecorder.start();
  statusEl.textContent = "‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ö‡¶≤‡¶õ‡ßá... ‡¶™‡ßç‡¶∞‡¶¶‡¶§‡ßç‡¶§ ‡¶¨‡¶æ‡¶ï‡ßç‡¶Ø ‡¶™‡¶°‡¶º‡ßÅ‡¶®‡•§";
  floating.classList.remove("hidden");
  startBtn.disabled = true;
  stopBtn.disabled = false;
};

stopBtn.onclick = () => {
  if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
  statusEl.textContent = "‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶∂‡ßá‡¶∑ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶ø‡¶≠‡¶ø‡¶â ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...";
};

// Submit recording
submitBtn.onclick = async () => {
  if (!recordedBlob || !currentSentence) {
    alert("‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶°‡¶ø‡¶Ç ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®‡•§");
    return;
  }
  
  const selectedGender = getSelectedGender();
  if (!selectedGender) {
    alert("‡¶≤‡¶ø‡¶ô‡ßç‡¶ó ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§");
    return;
  }
  
  // Show uploading state
  statusEl.textContent = "‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá... ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§";
  submitBtn.disabled = true;
  retryBtn.disabled = true;
  startBtn.disabled = true;
  dialectSel.disabled = true;
  
  // Disable gender selection during upload
  const genderRadios = document.querySelectorAll('input[name="gender"]');
  genderRadios.forEach(radio => radio.disabled = true);
  
  // Add uploading class for spinner
  statusEl.classList.add('uploading');
  
  const form = new FormData();
  form.append("file", recordedBlob, "recording.webm");
  form.append("dialect", currentDialect);
  form.append("gender", selectedGender);
  form.append("index", String(currentIndex));
  form.append("sentence_id", String(currentSentence.id || currentSentence.sentenceId));
  form.append("sentence_text", currentSentence.text);

  try {
    const res = await fetch(`${BACKEND_URL}/api/upload`, { method: "POST", body: form });
    const data = await res.json();
    if (res.ok && data.success) {
      statusEl.textContent = `‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: ${data.recording?.filename || data.filename}`;
      // Flag this sentence for this dialect
      const sentenceId = currentSentence.id || currentSentence.sentenceId;
      if (!flagged[currentDialect]) flagged[currentDialect] = new Set();
      flagged[currentDialect].add(sentenceId);
      
      // Show progress update message
      statusEl.textContent = "‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®! ‡¶™‡ßç‡¶∞‡¶ó‡ßç‡¶∞‡ßá‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶π‡¶ö‡ßç‡¶õ‡ßá...";
      
      // Refresh dialect dropdown to show updated progress (without loading indicator)
      await loadDialects(false);
      
      statusEl.textContent = "‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶ó‡ßç‡¶∞‡ßá‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!";
      
      // Reset UI for next recording
      setTimeout(() => {
        resetUI();
      }, 2000);
      
    } else {
      statusEl.textContent = `‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: ${data.error || 'unknown'}`;
    }
  } catch (err) {
    console.error(err);
    statusEl.textContent = "‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§";
  } finally {
    // Remove uploading state
    statusEl.classList.remove('uploading');
    submitBtn.disabled = false;
    retryBtn.disabled = false;
    dialectSel.disabled = false;
    
    // Re-enable gender selection
    genderRadios.forEach(radio => radio.disabled = false);
  }
};

// Retry recording
retryBtn.onclick = () => {
  // Clean up preview
  if (audioPreview.src) {
    URL.revokeObjectURL(audioPreview.src);
    audioPreview.src = '';
  }
  
  // Reset UI
  resetUI();
};
